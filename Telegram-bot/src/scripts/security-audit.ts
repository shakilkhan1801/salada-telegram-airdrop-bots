#!/usr/bin/env ts-node\n\n/**\n * Security Audit Script\n * \n * This script performs a comprehensive security audit of the application configuration\n * and provides recommendations for improving security posture.\n * \n * Usage:\n *   npm run security:audit\n *   ts-node src/scripts/security-audit.ts\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { config } from '../config';\nimport { logger } from '../services/logger';\n\ninterface SecurityIssue {\n  level: 'critical' | 'high' | 'medium' | 'low' | 'info';\n  category: string;\n  title: string;\n  description: string;\n  recommendation: string;\n  autoFixAvailable?: boolean;\n}\n\ninterface SecurityAuditResult {\n  issues: SecurityIssue[];\n  score: number;\n  maxScore: number;\n  grade: 'A+' | 'A' | 'B' | 'C' | 'D' | 'F';\n  summary: {\n    critical: number;\n    high: number;\n    medium: number;\n    low: number;\n    info: number;\n  };\n}\n\nclass SecurityAuditor {\n  private issues: SecurityIssue[] = [];\n  \n  private addIssue(issue: SecurityIssue): void {\n    this.issues.push(issue);\n  }\n  \n  private auditJWTSecrets(): void {\n    // Check JWT secret lengths\n    if (config.security.adminJwtSecret.length < 64) {\n      this.addIssue({\n        level: 'critical',\n        category: 'Authentication',\n        title: 'JWT Secret Too Short',\n        description: `Admin JWT secret is only ${config.security.adminJwtSecret.length} characters long`,\n        recommendation: 'Use minimum 64-character cryptographically secure random string. Run: npm run secrets:rotate',\n        autoFixAvailable: true\n      });\n    }\n    \n    if (config.security.refreshTokenSecret.length < 64) {\n      this.addIssue({\n        level: 'critical',\n        category: 'Authentication',\n        title: 'Refresh Token Secret Too Short',\n        description: `Refresh token secret is only ${config.security.refreshTokenSecret.length} characters long`,\n        recommendation: 'Use minimum 64-character cryptographically secure random string. Run: npm run secrets:rotate',\n        autoFixAvailable: true\n      });\n    }\n    \n    // Check if secrets are the same\n    if (config.security.adminJwtSecret === config.security.refreshTokenSecret) {\n      this.addIssue({\n        level: 'critical',\n        category: 'Authentication',\n        title: 'Identical JWT Secrets',\n        description: 'Admin JWT secret and refresh token secret are identical',\n        recommendation: 'Use different secrets for access and refresh tokens. Run: npm run secrets:rotate',\n        autoFixAvailable: true\n      });\n    }\n    \n    // Check for weak patterns\n    const weakPatterns = ['default', 'admin', 'secret', 'jwt', 'token', '123456', 'password'];\n    const adminHasWeak = weakPatterns.some(pattern => \n      config.security.adminJwtSecret.toLowerCase().includes(pattern.toLowerCase())\n    );\n    const refreshHasWeak = weakPatterns.some(pattern => \n      config.security.refreshTokenSecret.toLowerCase().includes(pattern.toLowerCase())\n    );\n    \n    if (adminHasWeak) {\n      this.addIssue({\n        level: 'high',\n        category: 'Authentication',\n        title: 'Weak JWT Secret Pattern',\n        description: 'Admin JWT secret contains predictable patterns',\n        recommendation: 'Use cryptographically secure random string without common words. Run: npm run secrets:rotate',\n        autoFixAvailable: true\n      });\n    }\n    \n    if (refreshHasWeak) {\n      this.addIssue({\n        level: 'high',\n        category: 'Authentication',\n        title: 'Weak Refresh Token Secret Pattern',\n        description: 'Refresh token secret contains predictable patterns',\n        recommendation: 'Use cryptographically secure random string without common words. Run: npm run secrets:rotate',\n        autoFixAvailable: true\n      });\n    }\n  }\n  \n  private auditAdminKeys(): void {\n    if (config.admin.key.length < 32) {\n      this.addIssue({\n        level: 'high',\n        category: 'Access Control',\n        title: 'Admin Key Too Short',\n        description: `Admin key is only ${config.admin.key.length} characters long`,\n        recommendation: 'Use minimum 32-character secure random string for admin key'\n      });\n    }\n    \n    // Check for weak admin key patterns\n    const weakPatterns = ['admin', 'key', 'password', '123456', 'secret'];\n    const hasWeakPattern = weakPatterns.some(pattern => \n      config.admin.key.toLowerCase().includes(pattern.toLowerCase())\n    );\n    \n    if (hasWeakPattern) {\n      this.addIssue({\n        level: 'medium',\n        category: 'Access Control',\n        title: 'Weak Admin Key Pattern',\n        description: 'Admin key contains predictable patterns',\n        recommendation: 'Use cryptographically secure random string without common words'\n      });\n    }\n  }\n  \n  private auditEnvironmentSecurity(): void {\n    // Check if running in production with proper settings\n    if (config.isProd) {\n      if (!process.env.ADMIN_JWT_SECRET) {\n        this.addIssue({\n          level: 'critical',\n          category: 'Configuration',\n          title: 'Production Missing JWT Secret',\n          description: 'Running in production without explicit ADMIN_JWT_SECRET',\n          recommendation: 'Set ADMIN_JWT_SECRET environment variable with secure random string'\n        });\n      }\n      \n      if (!process.env.REFRESH_TOKEN_SECRET) {\n        this.addIssue({\n          level: 'critical',\n          category: 'Configuration',\n          title: 'Production Missing Refresh Secret',\n          description: 'Running in production without explicit REFRESH_TOKEN_SECRET',\n          recommendation: 'Set REFRESH_TOKEN_SECRET environment variable with secure random string'\n        });\n      }\n      \n      if (config.storage.source === 'file') {\n        this.addIssue({\n          level: 'medium',\n          category: 'Data Storage',\n          title: 'File Storage in Production',\n          description: 'Using file storage in production environment',\n          recommendation: 'Consider using MongoDB for better performance and reliability'\n        });\n      }\n    }\n    \n    // Check for .env file security\n    const envPath = './.env';\n    if (fs.existsSync(envPath)) {\n      try {\n        const stats = fs.statSync(envPath);\n        const permissions = (stats.mode & parseInt('777', 8)).toString(8);\n        \n        if (permissions !== '600' && permissions !== '644') {\n          this.addIssue({\n            level: 'medium',\n            category: 'File Security',\n            title: 'Insecure .env File Permissions',\n            description: `.env file has permissions ${permissions}`,\n            recommendation: 'Set .env file permissions to 600: chmod 600 .env'\n          });\n        }\n      } catch (error) {\n        // Ignore permission check errors on some systems\n      }\n    }\n  }\n  \n  private auditSecurityFeatures(): void {\n    if (!config.security.enableMultiAccountDetection) {\n      this.addIssue({\n        level: 'medium',\n        category: 'Fraud Prevention',\n        title: 'Multi-Account Detection Disabled',\n        description: 'Multi-account detection is disabled',\n        recommendation: 'Enable multi-account detection to prevent abuse: ENABLE_MULTI_ACCOUNT_DETECTION=true'\n      });\n    }\n    \n    if (!config.security.enableDeviceFingerprinting) {\n      this.addIssue({\n        level: 'medium',\n        category: 'Fraud Prevention',\n        title: 'Device Fingerprinting Disabled',\n        description: 'Device fingerprinting is disabled',\n        recommendation: 'Enable device fingerprinting for better security: ENABLE_DEVICE_FINGERPRINTING=true'\n      });\n    }\n    \n    if (!config.security.autoBlockViolations) {\n      this.addIssue({\n        level: 'low',\n        category: 'Automation',\n        title: 'Auto-Block Disabled',\n        description: 'Automatic blocking of violations is disabled',\n        recommendation: 'Consider enabling auto-block for better security: AUTO_BLOCK_VIOLATIONS=true'\n      });\n    }\n    \n    if (config.security.maxUsersPerIp > 3) {\n      this.addIssue({\n        level: 'medium',\n        category: 'Access Control',\n        title: 'High Users Per IP Limit',\n        description: `Allowing ${config.security.maxUsersPerIp} users per IP address`,\n        recommendation: 'Consider lowering MAX_USERS_PER_IP to prevent abuse (recommended: 1-3)'\n      });\n    }\n  }\n  \n  private auditRateLimiting(): void {\n    if (!config.rateLimit.enabled) {\n      this.addIssue({\n        level: 'high',\n        category: 'Rate Limiting',\n        title: 'Rate Limiting Disabled',\n        description: 'API rate limiting is disabled',\n        recommendation: 'Enable rate limiting to prevent abuse: RATE_LIMIT_ENABLED=true'\n      });\n    }\n    \n    if (config.rateLimit.maxRequests > 1000) {\n      this.addIssue({\n        level: 'medium',\n        category: 'Rate Limiting',\n        title: 'High Rate Limit',\n        description: `Rate limit allows ${config.rateLimit.maxRequests} requests per window`,\n        recommendation: 'Consider lowering RATE_LIMIT_MAX_REQUESTS for better protection'\n      });\n    }\n  }\n  \n  private auditDataSecurity(): void {\n    // Check fingerprint encryption\n    if (config.security.fingerprintEncryptionKey.length < 32) {\n      this.addIssue({\n        level: 'medium',\n        category: 'Data Protection',\n        title: 'Weak Fingerprint Encryption',\n        description: `Fingerprint encryption key is only ${config.security.fingerprintEncryptionKey.length} characters`,\n        recommendation: 'Use minimum 32-character encryption key for fingerprint data'\n      });\n    }\n    \n    if (config.security.fingerprintSalt.length < 32) {\n      this.addIssue({\n        level: 'medium',\n        category: 'Data Protection',\n        title: 'Weak Fingerprint Salt',\n        description: `Fingerprint salt is only ${config.security.fingerprintSalt.length} characters`,\n        recommendation: 'Use minimum 32-character salt for fingerprint hashing'\n      });\n    }\n  }\n  \n  private auditLogging(): void {\n    if (config.logging.level === 'debug' && config.isProd) {\n      this.addIssue({\n        level: 'low',\n        category: 'Information Disclosure',\n        title: 'Debug Logging in Production',\n        description: 'Debug logging enabled in production',\n        recommendation: 'Set LOG_LEVEL to \"info\" or \"warn\" in production'\n      });\n    }\n    \n    if (!config.logging.fileEnabled) {\n      this.addIssue({\n        level: 'low',\n        category: 'Monitoring',\n        title: 'File Logging Disabled',\n        description: 'Log file creation is disabled',\n        recommendation: 'Enable file logging for audit trails: LOG_FILE_ENABLED=true'\n      });\n    }\n  }\n  \n  private calculateScore(): { score: number; maxScore: number; grade: string } {\n    let score = 100;\n    const maxScore = 100;\n    \n    // Deduct points based on issue severity\n    for (const issue of this.issues) {\n      switch (issue.level) {\n        case 'critical':\n          score -= 25;\n          break;\n        case 'high':\n          score -= 15;\n          break;\n        case 'medium':\n          score -= 10;\n          break;\n        case 'low':\n          score -= 5;\n          break;\n        case 'info':\n          score -= 1;\n          break;\n      }\n    }\n    \n    score = Math.max(0, score); // Don't go below 0\n    \n    let grade: string;\n    if (score >= 95) grade = 'A+';\n    else if (score >= 90) grade = 'A';\n    else if (score >= 80) grade = 'B';\n    else if (score >= 70) grade = 'C';\n    else if (score >= 60) grade = 'D';\n    else grade = 'F';\n    \n    return { score, maxScore, grade };\n  }\n  \n  public performAudit(): SecurityAuditResult {\n    console.log('🔍 Starting Security Audit...');\n    console.log('============================');\n    \n    // Run all audit checks\n    this.auditJWTSecrets();\n    this.auditAdminKeys();\n    this.auditEnvironmentSecurity();\n    this.auditSecurityFeatures();\n    this.auditRateLimiting();\n    this.auditDataSecurity();\n    this.auditLogging();\n    \n    // Calculate score and grade\n    const { score, maxScore, grade } = this.calculateScore();\n    \n    // Categorize issues\n    const summary = {\n      critical: this.issues.filter(i => i.level === 'critical').length,\n      high: this.issues.filter(i => i.level === 'high').length,\n      medium: this.issues.filter(i => i.level === 'medium').length,\n      low: this.issues.filter(i => i.level === 'low').length,\n      info: this.issues.filter(i => i.level === 'info').length\n    };\n    \n    const result: SecurityAuditResult = {\n      issues: this.issues,\n      score,\n      maxScore,\n      grade: grade as any,\n      summary\n    };\n    \n    return result;\n  }\n}\n\nconst displayResults = (result: SecurityAuditResult): void => {\n  console.log('\\n📊 Security Audit Results');\n  console.log('=========================');\n  console.log('');\n  \n  // Overall score\n  const scoreColor = result.score >= 90 ? '\\x1b[32m' : result.score >= 70 ? '\\x1b[33m' : '\\x1b[31m';\n  console.log(`Overall Security Score: ${scoreColor}${result.score}/${result.maxScore} (Grade: ${result.grade})\\x1b[0m`);\n  console.log('');\n  \n  // Issue summary\n  console.log('Issue Summary:');\n  if (result.summary.critical > 0) console.log(`  ❌ Critical: ${result.summary.critical}`);\n  if (result.summary.high > 0) console.log(`  🔴 High: ${result.summary.high}`);\n  if (result.summary.medium > 0) console.log(`  🟡 Medium: ${result.summary.medium}`);\n  if (result.summary.low > 0) console.log(`  🔵 Low: ${result.summary.low}`);\n  if (result.summary.info > 0) console.log(`  ℹ️  Info: ${result.summary.info}`);\n  \n  if (result.issues.length === 0) {\n    console.log('  ✅ No issues found!');\n    return;\n  }\n  \n  console.log('\\n🔍 Detailed Issues:');\n  console.log('==================');\n  \n  // Group issues by level\n  const levels: Array<SecurityIssue['level']> = ['critical', 'high', 'medium', 'low', 'info'];\n  \n  for (const level of levels) {\n    const levelIssues = result.issues.filter(i => i.level === level);\n    if (levelIssues.length === 0) continue;\n    \n    const levelIcon = {\n      critical: '❌',\n      high: '🔴',\n      medium: '🟡',\n      low: '🔵',\n      info: 'ℹ️'\n    }[level];\n    \n    console.log(`\\n${levelIcon} ${level.toUpperCase()} Issues:`);\n    console.log('-'.repeat(20));\n    \n    for (const issue of levelIssues) {\n      console.log(`\\n🏷️  ${issue.category}: ${issue.title}`);\n      console.log(`   ${issue.description}`);\n      console.log(`   💡 ${issue.recommendation}`);\n      if (issue.autoFixAvailable) {\n        console.log(`   🔧 Auto-fix available`);\n      }\n    }\n  }\n  \n  // Quick fix suggestions\n  const autoFixIssues = result.issues.filter(i => i.autoFixAvailable);\n  if (autoFixIssues.length > 0) {\n    console.log('\\n🔧 Quick Fixes Available:');\n    console.log('=========================');\n    console.log('• Run: npm run secrets:rotate (fixes JWT secret issues)');\n    console.log('• Run: npm run admin:create (creates secure admin user)');\n    console.log('• Run: chmod 600 .env (fixes file permissions)');\n  }\n  \n  // Overall recommendations\n  console.log('\\n📋 General Recommendations:');\n  console.log('============================');\n  \n  if (result.summary.critical > 0) {\n    console.log('🚨 URGENT: Fix critical issues immediately before production use!');\n  }\n  \n  if (result.summary.high > 0) {\n    console.log('⚠️  HIGH: Address high-priority issues within 24 hours');\n  }\n  \n  console.log('• Regularly rotate JWT secrets (every 30-90 days)');\n  console.log('• Monitor security logs for suspicious activity');\n  console.log('• Keep dependencies updated');\n  console.log('• Use environment variables for all secrets');\n  console.log('• Enable rate limiting and monitoring in production');\n  console.log('• Implement proper backup and disaster recovery procedures');\n  \n  console.log(`\\n🕐 Audit completed at: ${new Date().toISOString()}`);\n};\n\nconst saveAuditReport = (result: SecurityAuditResult): void => {\n  try {\n    const reportDir = './data/security/audits';\n    const reportFile = path.join(reportDir, `security-audit-${Date.now()}.json`);\n    \n    // Ensure directory exists\n    fs.mkdirSync(reportDir, { recursive: true });\n    \n    // Create detailed report\n    const report = {\n      timestamp: new Date().toISOString(),\n      environment: process.env.NODE_ENV || 'unknown',\n      score: result.score,\n      maxScore: result.maxScore,\n      grade: result.grade,\n      summary: result.summary,\n      issues: result.issues,\n      systemInfo: {\n        nodeVersion: process.version,\n        platform: process.platform,\n        arch: process.arch\n      }\n    };\n    \n    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));\n    console.log(`\\n📄 Detailed report saved: ${reportFile}`);\n  } catch (error) {\n    console.error('⚠️  Failed to save audit report:', error);\n  }\n};\n\nconst main = async (): Promise<void> => {\n  try {\n    const auditor = new SecurityAuditor();\n    const result = auditor.performAudit();\n    \n    displayResults(result);\n    saveAuditReport(result);\n    \n    // Log to application logger\n    logger.info('Security audit completed', {\n      score: result.score,\n      grade: result.grade,\n      issues: result.summary,\n      timestamp: new Date().toISOString()\n    });\n    \n    // Exit with error code if critical issues found\n    if (result.summary.critical > 0) {\n      console.log('\\n❌ Exiting with error code due to critical security issues');\n      process.exit(1);\n    }\n    \n  } catch (error) {\n    console.error('Fatal error during security audit:', error);\n    logger.error('Security audit failed:', error);\n    process.exit(1);\n  }\n};\n\n// Export for use as module\nexport { SecurityAuditor };\n\n// Run if called directly\nif (require.main === module) {\n  main().catch(console.error);\n}